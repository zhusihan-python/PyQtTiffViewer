<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- <meta http-equiv="X-UA-Compatible" content="IE=edge"> -->
  <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
  <title>tiffviewer_demo</title>
  <script src="https://d3js.org/d3-color.v2.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js"></script>
<!--  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/geojs/1.8.3/geo.min.js"></script>-->
  <script type="text/javascript" src="geo.min.js"></script>
  <script type="text/javascript" src="qwebchannel.js"></script>
</head>
<body>
<div class="wrapper">
  <div id="imageViewer" style="width: 100%; height: 100%; z-index: 10;"></div>
  <div class="slidecontainer">
    <button type="button" class="collapsible" id="displayControlsToggle">Toggle Controls</button>
    <div id="displayControls">
      <label for="rasterOpacityRange">Raster Layer Opacity: </label>
      <input type="range" min="1" max="100" value="100" class="overlay" id="rasterOpacityRange" onChange="updateTilesOpacity(event, value)" onInput="updateTilesOpacity(event, value)" style="top: 5px; left: 5px;">
      <br />
      <label for="bandChoice">Choose a band:</label>
      <select id="bandChoice" onChange='bandChange();'>
        <option>-- none --</option>
      </select>
      <br />
      <div id='colorsSubGroup' style="display: none;">
        <label for="colors">Choose a colormap:</label>
        <select id="colors" onChange='changeColors();'>
          <option>-- none --</option>
        </select>
        <br />
        <input id="mincolor" type="number" step="0.01" onChange='changeColors();'>
        <input id="maxcolor" type="number" step="0.01" onChange='changeColors();'>
      </div>
      <div>
      <img id="thumbnail" />
      </div>
      <div id="metadataViewer">
        <button type="button" id="copyMetadataButton" onclick="copyMetadata();">Copy Metadata</button>
      </div>
    </div>
  </div>
</div>
</body>
<script>
  var host = undefined;
  var thumbnailUrl = undefined;
  var tileUrl = undefined;
  var tile_data = undefined;
  var baseApi = 'api';

  const windowSearch = new URLSearchParams(window.location.search);
  const windowSearchParams = Object.fromEntries(windowSearch.entries());

  thumbnail.src = thumbnailUrl;

  if (windowSearchParams['min']) {
    colorsMin.value = windowSearchParams['min']
  }
  if (windowSearchParams['max']) {
    colorsMax.value = windowSearchParams['max']
  }

  var baseEndpoint = 'api/imagefile';
  const displayControlsToggle = document.getElementById('displayControlsToggle');
  const displayControls = document.getElementById('displayControls');
  addToggleListener(displayControlsToggle, displayControls);

  var colorsSubGroup = document.getElementById('colorsSubGroup');
  var colorsDropdown = document.getElementById('colors');
  var bandDropdown = document.getElementById('bandChoice');
  var colorsMin = document.getElementById('mincolor');
  var colorsMax = document.getElementById('maxcolor');
  var thumbnail = document.getElementById('thumbnail');
  var bands;

  var imageId = 1;
  if (host === undefined) {
    host = window.location.protocol + "//" + window.location.host;
  }
  console.log("index host : " + host);
  console.log("index baseEndpoint : " + baseEndpoint);
  console.log("index imageId : " + imageId);
  tileUrl = `${host}/${baseEndpoint}/${imageId}/tiles/{z}/{x}/{y}.png`;

  var metadata = undefined;
  const containerRef = document.getElementById('imageViewer')
  var imageLayer;
  var viewer;

  var Bridge = null;
  var x = 5;
  window.onload = function () {
    new QWebChannel(qt.webChannelTransport,
      function(channel) {
        Bridge = channel.objects.Bridge;
        Bridge.get_bands(111, function (pyval) {
          var bands = JSON.parse(pyval);
          for (const [source, values] of Object.entries(bands)) {
            const interp = values['interpretation']
            var newOption = document.createElement('option');
            newOption.value = source;
            newOption.text = interp ? `${source}: ${interp}` : source;
            bandDropdown.appendChild(newOption)
          }
          if (windowSearchParams['band']) {
            bandDropdown.value = windowSearchParams['band'] ? windowSearchParams['band'] : '-- none --';
            colorsSubGroup.style.display = 'block';
          }
        });

        Bridge.get_color_maps(function (pyval) {
          let data = JSON.parse(pyval);
          if ( data !== undefined ) {
            for (const [source, values] of Object.entries(data)) {
              const interp = values['interpretation']
              var newOption = document.createElement('option');
              newOption.value = source;
              newOption.text = interp ? `${source}: ${interp}` : source;
              colorsDropdown.appendChild(newOption)
            }
            if (windowSearchParams['colors']) {
              colorsDropdown.value = windowSearchParams['colors'] ? windowSearchParams['colors'] : '-- none --';
              colorsSubGroup.style.display = 'block';
            }
          }
          // for (const [source, indices] of Object.entries(data)) {
          //   for (const index in indices) {
          //     const option = data[source][index];
          //     var newOption = document.createElement('option');
          //     newOption.value = option;
          //     newOption.text = option;
          //     colorsDropdown.appendChild(newOption);
          //   }
          // }
          // colorsDropdown.value = windowSearchParams['palette'] ? windowSearchParams['palette'] : '-- none --';
        });

        // tileUrl = async function (x, y, z, subdomains) {
        //   console.log("input x,y,z,subdomains in index.html", x, y, z, subdomains);
        //
        //   let promise = new Promise(function (resolve, reject) {
        //     Bridge.get_tile(x, y, z, function (pyval) {
        //       tile_data = "data:image/png;base64," + pyval;
        //       // console.log("tile_data in index.html", tile_data);
        //       resolve(tile_data);
        //     });
        //   });
        //
        //   // return promise.then(function (value) {
        //   //   console.log("tile_data in index.html promise then", value);
        //   //   return value;
        //   // });
        //   // let res = await promise;
        //   // console.log("res return by promise", res);
        //   // return res;
        //   return await promise;
        // };

        // tileUrl = function (x, y, z, subdomains) {
        //   console.log("input x,y,z,subdomains in index.html", x, y, z, subdomains);
        //   let finished = false;
        //
        //   Bridge.get_tile(x, y, z, function (pyval) {
        //     tile_data = "data:image/png;base64," + pyval;
        //     console.log("tile_data return by get_tile", tile_data);
        //     updateTileLayer(tile_data);
        //   });
        //
        //   // console.log("tile_data before return in tileUrl", tile_data);
        //   // return tile_data;
        // }

        Bridge.get_metadata(function (pyval) {
          console.log("into get_metadata", pyval);
          var tileinfo = JSON.parse(pyval);
          console.log("into get_metadata tileinfo: ", tileinfo['geospatial']);
          if (tileinfo['geospatial']) {
            updateTileUrlOption('projection', 'EPSG:3857');

            // Initialize the map
            viewer = geo.map({
              node: '#imageViewer',
              clampBoundsX: true
            })
            var basemapLayer = viewer.createLayer('osm', {
              source: 'osm',
              gcs: 'EPSG:3857' // web mercator
            });

            function setBounds(extent, setMax = false) {
              console.log("into setBounds");
              if (extent != undefined && extent.xmin != undefined) {
                let xc = (extent.xmax - extent.xmin) * 0.2
                let yc = (extent.ymax - extent.ymin) * 0.2
                if (xc === 0) {
                  xc = 0.01
                }
                if (yc === 0) {
                  yc = 0.01
                }
                var bounds = {
                  left: Math.max(extent.xmin - xc, -180.0),
                  right: Math.min(extent.xmax + xc, 180.0),
                  top: Math.min(extent.ymax + yc, 89.9999),
                  bottom: Math.max(extent.ymin - yc, -89.9999)
                }
                viewer.bounds(bounds);
                if (setMax) {
                  viewer.maxBounds(bounds)
                } else {
                  viewer.zoom(viewer.zoom() - 0.25);
                }
              }
            }
            setBounds(tileinfo.bounds);

            // Tile layer for showing rasters/images with large_image
            imageLayer = viewer.createLayer('osm', {
              keepLower: false,
              attribution: '',
              autoshareRenderer: false,
            });

            console.log("imageLayer in get_metadata if", imageLayer);

            const dataset_bb = tileinfo.bounds;
            imageLayer.isValid = (index) => {
              const tileBounds = imageLayer.gcsTileBounds(index);
              return tileBounds.left <= dataset_bb.xmax &&
                tileBounds.right >= dataset_bb.xmin &&
                tileBounds.top >= dataset_bb.ymin &&
                tileBounds.bottom <= dataset_bb.ymax;
            }
            imageLayer.idleAfter = 'all';

            // Increase zoom range from default of 16
            viewer.zoomRange({
              min: 0,
              max: 20,
            })
          } else {
            console.log("into get_metadata else");
            const params = geo.util.pixelCoordinateParams(
              '#imageViewer', tileinfo.sizeX, tileinfo.sizeY, tileinfo.tileWidth, tileinfo.tileHeight);
            params.layer.url = tileUrl;
            console.log("get_metadata else params layer", params.layer);
            viewer = geo.map(params.map);

            viewer.zoomRange({
              // do not set a min limit so that bounds clamping determines min
              min: -Infinity,
              max: 12,
            });
            console.log("get_metadata else viewer", viewer);
            try {
              imageLayer = viewer.createLayer('osm', params.layer);
            }
            catch (err) {
              console.log("createLayer get err", err)
            }

            console.log("imageLayer in get_metadata else", imageLayer);
          }
          // Change default interactor options
          const interactorOpts = viewer.interactor().options();
          interactorOpts.zoomAnimation = {
            enabled: false,
          };
          interactorOpts.momentum = {
            enabled: true,
          };
          viewer.interactor().options(interactorOpts);


          var ui = viewer.createLayer('ui');
          // Create a zoom slider widget
          ui.createWidget('slider', {
            position: {
              left: 40,
              top: 40
            }
          });
          bandChange();
        });

        Bridge.get_thumbnail(function(thumbnail) {
          // console.log("thumbnail return by get_thumbnail", thumbnail);
          if (thumbnail) {
            $('#thumbnail').attr('src', "data:image/png;base64,"+thumbnail);
          }
        });

        // function updateTileLayerInner() {
        //   console.log("into updateTileLayerInner", tile_data);
        //   // imageLayer.url(tile_data);
        // }

        tileUrl = function (x, y, z, subdomains) {
          console.log("input x,y,z,subdomains in index.html", x, y, z, subdomains);

          Bridge.get_tile(x, y, z, function (pyval) {
            tile_data = "data:image/png;base64," + pyval;
            console.log("tile_data return by get_tile", tile_data);
            console.log("viewer", viewer);
            console.log("imageLayer", imageLayer);
            imageLayer.url(tile_data);
            // updateTileLayerInner();
          });

          // console.log("tile_data before return in tileUrl", tile_data);
          // return tile_data;
        }

        Bridge.getRef(x, function(pyval) {
          Bridge.printRef(pyval);
        });

        Bridge.get_metadata(function (pyval) {
          metadata = JSON.parse(pyval);
        });
      }
    );
  };

  function updateTileUrlOption(option, value) {
    // if (thumbnailUrl === undefined) {
    //   thumbnailUrl = `${host}/${baseEndpoint}/${imageId}/thumbnail.png`;
    // }
    // const url = new URL(tileUrl);
    // // const urlThumb = new URL(thumbnailUrl);
    // if (value === undefined) {
    //   url.searchParams.delete(option);
    //   // urlThumb.searchParams.delete(option);
    // } else {
    //   url.searchParams.set(option, value);
    //   // urlThumb.searchParams.set(option, value);
    // }
    // const tileFormatEncoded = '/%7Bz%7D/%7Bx%7D/%7By%7D.';
    // const tileFormat = '/{z}/{x}/{y}.';
    // tileUrl = url.toString().replace(tileFormatEncoded, tileFormat);
    console.log("tileUrl return by updateTileUrlOption", tileUrl);
    // thumbnailUrl = urlThumb.toString();
    // insertWindowUrlParam(option, value);
  }

  function addToggleListener(uiToggle, uiContent, callback = null) {
    uiToggle.addEventListener('click', function() {
      this.classList.toggle('active');
      var state = null;
      if (uiContent.style.display === 'block') {
        uiContent.style.display = 'none';
        state = false;
      } else {
        uiContent.style.display = 'block';
        state = true;
      }
      // Call the custom callback if given
      if (callback != null) {
        callback(state);
      }
    });
    // Hide by default
    uiContent.style.display = 'none';
  }

  // fetch(`${host}/${baseEndpoint}/${imageId}/bands`).then(response => {
  //   response.json().then(data => {
  //     bands = data;
  //     for (const [source, values] of Object.entries(bands)) {
  //       const interp = values['interpretation']
  //       var newOption = document.createElement('option');
  //       newOption.value = source;
  //       newOption.text = interp ? `${source}: ${interp}` : source;
  //       bandDropdown.appendChild(newOption)
  //     }
  //     if (windowSearchParams['band']) {
  //       bandDropdown.value = windowSearchParams['band'] ? windowSearchParams['band'] : '-- none --';
  //       colorsSubGroup.style.display = 'block';
  //     }
  //   });
  // })

  // Bridge.get_bands(111, function (pyval) {
  //     bands = pyval;
  //     for (const [source, values] of Object.entries(bands)) {
  //       const interp = values['interpretation']
  //       var newOption = document.createElement('option');
  //       newOption.value = source;
  //       newOption.text = interp ? `${source}: ${interp}` : source;
  //       bandDropdown.appendChild(newOption)
  //     }
  //     if (windowSearchParams['band']) {
  //       bandDropdown.value = windowSearchParams['band'] ? windowSearchParams['band'] : '-- none --';
  //       colorsSubGroup.style.display = 'block';
  //     }
  //   });

  // fetch(`${host}/${baseApi}/large-image/colormaps`)
  //   .then(response => response.json())
  //   .then(data => {
  //     for (const [source, indices] of Object.entries(data)) {
  //       for (const index in indices) {
  //         const option = data[source][index];
  //         var newOption = document.createElement('option');
  //         newOption.value = option;
  //         newOption.text = option;
  //         colorsDropdown.appendChild(newOption);
  //       }
  //     }
  //     colorsDropdown.value = windowSearchParams['palette'] ? windowSearchParams['palette'] : '-- none --';
  //   });

  function changeColors() {
    colorsSubGroup.display = 'block';
    var cmap;
    if (colorsDropdown.value == '-- none --') {
      cmap = undefined;
    } else {
      cmap = colorsDropdown.value;
    }
    updateTileUrlOption('palette', cmap);
    updateTileUrlOption('min', colorsMin.value);
    updateTileUrlOption('max', colorsMax.value);
    updateTileLayer();
    thumbnail.src = thumbnailUrl;
  }

  function bandChange() {
    if (bandDropdown.value == '-- none --') {
      updateTileUrlOption('palette', undefined);
      updateTileUrlOption('band', undefined);
      updateTileUrlOption('min', undefined);
      updateTileUrlOption('max', undefined);
      colorsSubGroup.style.display = 'none';
      updateTileLayer();
      thumbnail.src = thumbnailUrl;
    } else {
      colorsSubGroup.style.display = 'block';
      band = bandDropdown.value;
      updateTileUrlOption('band', band);
      colorsMin.placeholder = bands[band]['min'];
      colorsMax.placeholder = bands[band]['max'];
      changeColors();
    }
  }


  // fetch(`${host}/${baseEndpoint}/${imageId}/metadata`)
  //   .then(response => response.json())
  //   .then(data => {
  //     metadata = data
  //   });
  // Bridge.get_metadata(function (pyval) {
  //   metadata = JSON.parse(pyval);
  // });

  async function copyMetadata() {
    var copyText = JSON.stringify(metadata);
    await navigator.clipboard.writeText(copyText);
    alert("Copied image metadata");
  }

  // const containerRef = document.getElementById('imageViewer')
  // var imageLayer;
  // var viewer;

  // fetch(`${host}/${baseEndpoint}/${imageId}/metadata`)
  // .then(response => response.json())
  // .then(tileinfo => {
  //   if (tileinfo['geospatial']) {
  //     updateTileUrlOption('projection', 'EPSG:3857');
  //
  //     // Initialize the map
  //     viewer = geo.map({
  //       node: '#imageViewer',
  //       clampBoundsX: true
  //     })
  //     var basemapLayer = viewer.createLayer('osm', {
  //       source: 'osm',
  //       gcs: 'EPSG:3857' // web mercator
  //     });
  //
  //     function setBounds(extent, setMax = false) {
  //       if (extent != undefined && extent.xmin != undefined) {
  //         let xc = (extent.xmax - extent.xmin) * 0.2
  //         let yc = (extent.ymax - extent.ymin) * 0.2
  //         if (xc === 0) {
  //           xc = 0.01
  //         }
  //         if (yc === 0) {
  //           yc = 0.01
  //         }
  //         var bounds = {
  //           left: Math.max(extent.xmin - xc, -180.0),
  //           right: Math.min(extent.xmax + xc, 180.0),
  //           top: Math.min(extent.ymax + yc, 89.9999),
  //           bottom: Math.max(extent.ymin - yc, -89.9999)
  //         }
  //         viewer.bounds(bounds);
  //         if (setMax) {
  //           viewer.maxBounds(bounds)
  //         } else {
  //           viewer.zoom(viewer.zoom() - 0.25);
  //         }
  //       }
  //     }
  //     setBounds(tileinfo.bounds);
  //
  //     // Tile layer for showing rasters/images with large_image
  //     imageLayer = viewer.createLayer('osm', {
  //       keepLower: false,
  //       attribution: '',
  //       autoshareRenderer: false,
  //     });
  //
  //     const dataset_bb = tileinfo.bounds;
  //     imageLayer.isValid = (index) => {
  //       const tileBounds = imageLayer.gcsTileBounds(index);
  //       return tileBounds.left <= dataset_bb.xmax &&
  //         tileBounds.right >= dataset_bb.xmin &&
  //         tileBounds.top >= dataset_bb.ymin &&
  //         tileBounds.bottom <= dataset_bb.ymax;
  //     }
  //     imageLayer.idleAfter = 'all';
  //
  //     // Increase zoom range from default of 16
  //     viewer.zoomRange({
  //       min: 0,
  //       max: 20,
  //     })
  //   } else {
  //     const params = geo.util.pixelCoordinateParams(
  //       '#imageViewer', tileinfo.sizeX, tileinfo.sizeY, tileinfo.tileWidth, tileinfo.tileHeight);
  //     params.layer.url = tileUrl;
  //
  //     viewer = geo.map(params.map);
  //
  //     viewer.zoomRange({
  //       // do not set a min limit so that bounds clamping determines min
  //       min: -Infinity,
  //       max: 12,
  //     });
  //
  //     imageLayer = viewer.createLayer('osm', params.layer);
  //   }
  //   // Change default interactor options
  //   const interactorOpts = viewer.interactor().options();
  //   interactorOpts.zoomAnimation = {
  //     enabled: false,
  //   };
  //   interactorOpts.momentum = {
  //     enabled: true,
  //   };
  //   viewer.interactor().options(interactorOpts);
  //
  //
  //   var ui = viewer.createLayer('ui');
  //   // Create a zoom slider widget
  //   ui.createWidget('slider', {
  //     position: {
  //       left: 40,
  //       top: 40
  //     }
  //   });
  //   bandChange();
  // });

  function updateTileLayer() {
    console.log("into updateTileLayer", tile_data);
    imageLayer.url(tile_data);
  }

  function updateTilesOpacity(e, value) {
    value = Number(value) / 100.0;
    imageLayer.opacity(value);
  }
</script>
</html>
